<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MiraiCP: BS::thread_pool类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
 <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<a href="https://github.com/Nambers/MiraiCP" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MiraiCP
   &#160;<span id="projectnumber">v2.13.1</span>
   </div>
   <div id="projectbrief">MiraiCP api document</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a00360.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pri-methods">Private 成员函数</a> &#124;
<a href="#pri-static-methods">静态 Private 成员函数</a> &#124;
<a href="#pri-attribs">Private 属性</a> &#124;
<a href="a00357.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">BS::thread_pool类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>A fast, lightweight, and easy-to-use C++17 thread pool class.  
 <a href="a00360.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="a00026_source.html">BS_thread_pool.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> BS::thread_pool 的协作图:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00358.svg" width="744" height="1182"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:af0705b5edcf3809e4f133272e8070d12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#af0705b5edcf3809e4f133272e8070d12">thread_pool</a> (const <a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> thread_count_=0)</td></tr>
<tr class="memdesc:af0705b5edcf3809e4f133272e8070d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool.  <a href="a00360.html#af0705b5edcf3809e4f133272e8070d12">更多...</a><br /></td></tr>
<tr class="separator:af0705b5edcf3809e4f133272e8070d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7cc32367d0d0c020bf103782506998"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a1f7cc32367d0d0c020bf103782506998">~thread_pool</a> ()</td></tr>
<tr class="memdesc:a1f7cc32367d0d0c020bf103782506998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the thread pool. Waits for all tasks to complete, then destroys all threads. Note that if the pool is paused, then any tasks still in the queue will never be executed.  <a href="a00360.html#a1f7cc32367d0d0c020bf103782506998">更多...</a><br /></td></tr>
<tr class="separator:a1f7cc32367d0d0c020bf103782506998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5faf242cb0eacbb5c1142a2bd966468"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#ab5faf242cb0eacbb5c1142a2bd966468">get_tasks_queued</a> () const</td></tr>
<tr class="memdesc:ab5faf242cb0eacbb5c1142a2bd966468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently waiting in the queue to be executed by the threads.  <a href="a00360.html#ab5faf242cb0eacbb5c1142a2bd966468">更多...</a><br /></td></tr>
<tr class="separator:ab5faf242cb0eacbb5c1142a2bd966468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a07b4d97e3a9e40e3228e2ed1f9a717cc">get_tasks_running</a> () const</td></tr>
<tr class="memdesc:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently being executed by the threads.  <a href="a00360.html#a07b4d97e3a9e40e3228e2ed1f9a717cc">更多...</a><br /></td></tr>
<tr class="separator:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdec64ff8998d66017cc185ae397e064"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#afdec64ff8998d66017cc185ae397e064">get_tasks_total</a> () const</td></tr>
<tr class="memdesc:afdec64ff8998d66017cc185ae397e064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of unfinished tasks: either still in the queue, or running in a thread. Note that <a class="el" href="a00360.html#afdec64ff8998d66017cc185ae397e064" title="Get the total number of unfinished tasks: either still in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="a00360.html#ab5faf242cb0eacbb5c1142a2bd966468" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="a00360.html#a07b4d97e3a9e40e3228e2ed1f9a717cc" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a>.  <a href="a00360.html#afdec64ff8998d66017cc185ae397e064">更多...</a><br /></td></tr>
<tr class="separator:afdec64ff8998d66017cc185ae397e064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1cb80839e30f218818e99af4d1dc64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#afe1cb80839e30f218818e99af4d1dc64">get_thread_count</a> () const</td></tr>
<tr class="memdesc:afe1cb80839e30f218818e99af4d1dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads in the pool.  <a href="a00360.html#afe1cb80839e30f218818e99af4d1dc64">更多...</a><br /></td></tr>
<tr class="separator:afe1cb80839e30f218818e99af4d1dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7938f7b2b9140c3f6e729b48db79b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#adc7938f7b2b9140c3f6e729b48db79b2">is_paused</a> () const</td></tr>
<tr class="memdesc:adc7938f7b2b9140c3f6e729b48db79b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the pool is currently paused.  <a href="a00360.html#adc7938f7b2b9140c3f6e729b48db79b2">更多...</a><br /></td></tr>
<tr class="separator:adc7938f7b2b9140c3f6e729b48db79b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229fc62ea9874f840613fdefe1f6018b"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a229fc62ea9874f840613fdefe1f6018b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00352.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a229fc62ea9874f840613fdefe1f6018b">run_over</a> (It &amp;&amp;begin, It &amp;&amp;end, size_t inSize)</td></tr>
<tr class="memdesc:a229fc62ea9874f840613fdefe1f6018b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks.  <a href="a00360.html#a229fc62ea9874f840613fdefe1f6018b">更多...</a><br /></td></tr>
<tr class="separator:a229fc62ea9874f840613fdefe1f6018b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63b1085ad48295d7f653cbb36a286be"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T  = std::common_type_t&lt;T1, T2&gt;, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </td></tr>
<tr class="memitem:ab63b1085ad48295d7f653cbb36a286be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00352.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#ab63b1085ad48295d7f653cbb36a286be">parallelize_loop</a> (const T1 first_index, const T2 index_after_last, F &amp;&amp;loop, const size_t num_blocks=0)</td></tr>
<tr class="memdesc:ab63b1085ad48295d7f653cbb36a286be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks.  <a href="a00360.html#ab63b1085ad48295d7f653cbb36a286be">更多...</a><br /></td></tr>
<tr class="separator:ab63b1085ad48295d7f653cbb36a286be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4e0c7b8e0ac08d9cdad40defd36f30"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </td></tr>
<tr class="memitem:a2f4e0c7b8e0ac08d9cdad40defd36f30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00352.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a2f4e0c7b8e0ac08d9cdad40defd36f30">parallelize_loop</a> (const T index_after_last, F &amp;&amp;loop, const size_t num_blocks=0)</td></tr>
<tr class="memdesc:a2f4e0c7b8e0ac08d9cdad40defd36f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks. This overload is used for the special case where the first index is 0.  <a href="a00360.html#a2f4e0c7b8e0ac08d9cdad40defd36f30">更多...</a><br /></td></tr>
<tr class="separator:a2f4e0c7b8e0ac08d9cdad40defd36f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb5f1e179eb97f6458d4f77fbb331fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#aefb5f1e179eb97f6458d4f77fbb331fd">pause</a> ()</td></tr>
<tr class="memdesc:aefb5f1e179eb97f6458d4f77fbb331fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause the pool. The workers will temporarily stop retrieving new tasks out of the queue, although any tasks already executed will keep running until they are finished.  <a href="a00360.html#aefb5f1e179eb97f6458d4f77fbb331fd">更多...</a><br /></td></tr>
<tr class="separator:aefb5f1e179eb97f6458d4f77fbb331fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cec549d4a8729beac50f5eba3ec63f"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T  = std::common_type_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ae7cec549d4a8729beac50f5eba3ec63f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#ae7cec549d4a8729beac50f5eba3ec63f">push_loop</a> (const T1 first_index, const T2 index_after_last, F &amp;&amp;loop, const size_t num_blocks=0)</td></tr>
<tr class="memdesc:ae7cec549d4a8729beac50f5eba3ec63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Does not return a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a>, so the user must use <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.  <a href="a00360.html#ae7cec549d4a8729beac50f5eba3ec63f">更多...</a><br /></td></tr>
<tr class="separator:ae7cec549d4a8729beac50f5eba3ec63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffca1428e1f111220b5f9aed9ff9eac"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a2ffca1428e1f111220b5f9aed9ff9eac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a2ffca1428e1f111220b5f9aed9ff9eac">push_loop</a> (const T index_after_last, F &amp;&amp;loop, const size_t num_blocks=0)</td></tr>
<tr class="memdesc:a2ffca1428e1f111220b5f9aed9ff9eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Does not return a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a>, so the user must use <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. This overload is used for the special case where the first index is 0.  <a href="a00360.html#a2ffca1428e1f111220b5f9aed9ff9eac">更多...</a><br /></td></tr>
<tr class="separator:a2ffca1428e1f111220b5f9aed9ff9eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebd481672891be26e73f19f70b38e01"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A&gt; </td></tr>
<tr class="memitem:a2ebd481672891be26e73f19f70b38e01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a2ebd481672891be26e73f19f70b38e01">push_task</a> (F &amp;&amp;task, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:a2ebd481672891be26e73f19f70b38e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a function with zero or more arguments, but no return value, into the task queue. Does not return a future, so the user must use <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the task finishes executing, otherwise bad things will happen.  <a href="a00360.html#a2ebd481672891be26e73f19f70b38e01">更多...</a><br /></td></tr>
<tr class="separator:a2ebd481672891be26e73f19f70b38e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c00ae5f87608bbc12b05f1ddf231196"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A&gt; </td></tr>
<tr class="memitem:a2c00ae5f87608bbc12b05f1ddf231196"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#a2c00ae5f87608bbc12b05f1ddf231196">push_task_nolock</a> (F &amp;&amp;task, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:a2c00ae5f87608bbc12b05f1ddf231196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as push_task, but without locking the mutex.  <a href="a00360.html#a2c00ae5f87608bbc12b05f1ddf231196">更多...</a><br /></td></tr>
<tr class="separator:a2c00ae5f87608bbc12b05f1ddf231196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3623b19c51a513fe4612b2157b0314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a5d3623b19c51a513fe4612b2157b0314">reset</a> (const <a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> thread_count_=0)</td></tr>
<tr class="memdesc:a5d3623b19c51a513fe4612b2157b0314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the number of threads in the pool. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <a href="a00360.html#a5d3623b19c51a513fe4612b2157b0314">更多...</a><br /></td></tr>
<tr class="separator:a5d3623b19c51a513fe4612b2157b0314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff5c3b86d8c89227a2af192e3f96ef8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt; </td></tr>
<tr class="memitem:aeff5c3b86d8c89227a2af192e3f96ef8"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#aeff5c3b86d8c89227a2af192e3f96ef8">submit</a> (F &amp;&amp;task, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:aeff5c3b86d8c89227a2af192e3f96ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with zero or more arguments into the task queue. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an std::future&lt;void&gt; which can be used to wait until the task finishes.  <a href="a00360.html#aeff5c3b86d8c89227a2af192e3f96ef8">更多...</a><br /></td></tr>
<tr class="separator:aeff5c3b86d8c89227a2af192e3f96ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60f93ff4ee8fae28b5945eb9a6fc7fa"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt; </td></tr>
<tr class="memitem:ae60f93ff4ee8fae28b5945eb9a6fc7fa"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00360.html#ae60f93ff4ee8fae28b5945eb9a6fc7fa">submit_nolock</a> (F &amp;&amp;task, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae60f93ff4ee8fae28b5945eb9a6fc7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as submit, but without locking mutex.  <a href="a00360.html#ae60f93ff4ee8fae28b5945eb9a6fc7fa">更多...</a><br /></td></tr>
<tr class="separator:ae60f93ff4ee8fae28b5945eb9a6fc7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57048e0479f878af3ac3a27031a2d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#ad57048e0479f878af3ac3a27031a2d6e">unpause</a> ()</td></tr>
<tr class="memdesc:ad57048e0479f878af3ac3a27031a2d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpause the pool. The workers will resume retrieving new tasks out of the queue.  <a href="a00360.html#ad57048e0479f878af3ac3a27031a2d6e">更多...</a><br /></td></tr>
<tr class="separator:ad57048e0479f878af3ac3a27031a2d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e16153b1a14b5b4d8191168ccf6e4b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8">wait_for_tasks</a> ()</td></tr>
<tr class="memdesc:a1e16153b1a14b5b4d8191168ccf6e4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <a class="el" href="a00360.html#aeff5c3b86d8c89227a2af192e3f96ef8" title="Submit a function with zero or more arguments into the task queue. If the function has a return value...">submit()</a> instead, and call the wait() member function of the generated future.  <a href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8">更多...</a><br /></td></tr>
<tr class="separator:a1e16153b1a14b5b4d8191168ccf6e4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43e9ad7abf11f7f874c356a483eb76d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#ac43e9ad7abf11f7f874c356a483eb76d">resetThreadByIndex</a> (size_t index)</td></tr>
<tr class="memdesc:ac43e9ad7abf11f7f874c356a483eb76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">force reset a thread, only should be called when a deadly problem happen  <a href="a00360.html#ac43e9ad7abf11f7f874c356a483eb76d">更多...</a><br /></td></tr>
<tr class="separator:ac43e9ad7abf11f7f874c356a483eb76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:ac50afec1dec9015d36c90f49c9a4ff80"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#ac50afec1dec9015d36c90f49c9a4ff80">getCurrentThreadIndexView</a> ()</td></tr>
<tr class="separator:ac50afec1dec9015d36c90f49c9a4ff80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private 成员函数</h2></td></tr>
<tr class="memitem:a4b6564dcbe7b01efb736377917b489b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a4b6564dcbe7b01efb736377917b489b8">create_threads</a> ()</td></tr>
<tr class="memdesc:a4b6564dcbe7b01efb736377917b489b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the threads in the pool and assign a worker to each thread.  <a href="a00360.html#a4b6564dcbe7b01efb736377917b489b8">更多...</a><br /></td></tr>
<tr class="separator:a4b6564dcbe7b01efb736377917b489b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b4777cae9085a4fa792a334f1015d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a97b4777cae9085a4fa792a334f1015d6">destroy_threads</a> ()</td></tr>
<tr class="memdesc:a97b4777cae9085a4fa792a334f1015d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the threads in the pool.  <a href="a00360.html#a97b4777cae9085a4fa792a334f1015d6">更多...</a><br /></td></tr>
<tr class="separator:a97b4777cae9085a4fa792a334f1015d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40078e42bdcf2c562489984f94092e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#ad40078e42bdcf2c562489984f94092e9">determine_thread_count</a> (const <a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> thread_count_)</td></tr>
<tr class="memdesc:ad40078e42bdcf2c562489984f94092e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how many threads the pool should have, based on the parameter passed to the constructor or <a class="el" href="a00360.html#a5d3623b19c51a513fe4612b2157b0314" title="Reset the number of threads in the pool. Waits for all currently running tasks to be completed,...">reset()</a>.  <a href="a00360.html#ad40078e42bdcf2c562489984f94092e9">更多...</a><br /></td></tr>
<tr class="separator:ad40078e42bdcf2c562489984f94092e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bfe8e50c6bb28c590e965b27a6c1d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a77bfe8e50c6bb28c590e965b27a6c1d7">setThreadIndex</a> ()</td></tr>
<tr class="separator:a77bfe8e50c6bb28c590e965b27a6c1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f36df0501ab738b10baee833e9ed960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a6f36df0501ab738b10baee833e9ed960">worker</a> ()</td></tr>
<tr class="memdesc:a6f36df0501ab738b10baee833e9ed960"><td class="mdescLeft">&#160;</td><td class="mdescRight">A worker function to be assigned to each thread in the pool. Waits until it is notified by <a class="el" href="a00360.html#a2ebd481672891be26e73f19f70b38e01" title="Push a function with zero or more arguments, but no return value, into the task queue....">push_task()</a> that a task is available, and then retrieves the task from the queue and executes it. Once the task finishes, the worker notifies <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> in case it is waiting.  <a href="a00360.html#a6f36df0501ab738b10baee833e9ed960">更多...</a><br /></td></tr>
<tr class="separator:a6f36df0501ab738b10baee833e9ed960"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
静态 Private 成员函数</h2></td></tr>
<tr class="memitem:a03a26302bfc4d7a75df02e187af3a77b"><td class="memItemLeft" align="right" valign="top">static size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a03a26302bfc4d7a75df02e187af3a77b">getThreadIndex</a> ()</td></tr>
<tr class="separator:a03a26302bfc4d7a75df02e187af3a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private 属性</h2></td></tr>
<tr class="memitem:a144417a3a9099c5658911632b4092f91"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a> = false</td></tr>
<tr class="memdesc:a144417a3a9099c5658911632b4092f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable indicating whether the workers should pause. When set to true, the workers temporarily stop retrieving new tasks out of the queue, although any tasks already executed will keep running until they are finished. When set to false again, the workers resume retrieving tasks.  <a href="a00360.html#a144417a3a9099c5658911632b4092f91">更多...</a><br /></td></tr>
<tr class="separator:a144417a3a9099c5658911632b4092f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1230911736c885623eeb34c537dcd679"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a1230911736c885623eeb34c537dcd679">running</a> = false</td></tr>
<tr class="memdesc:a1230911736c885623eeb34c537dcd679"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable indicating to the workers to keep running. When set to false, the workers permanently stop working.  <a href="a00360.html#a1230911736c885623eeb34c537dcd679">更多...</a><br /></td></tr>
<tr class="separator:a1230911736c885623eeb34c537dcd679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3be4acff4c3d14b95b2cbad6dad6e"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a> = {}</td></tr>
<tr class="memdesc:aecb3be4acff4c3d14b95b2cbad6dad6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition variable used to notify <a class="el" href="a00360.html#a6f36df0501ab738b10baee833e9ed960" title="A worker function to be assigned to each thread in the pool. Waits until it is notified by push_task(...">worker()</a> that a new task has become available.  <a href="a00360.html#aecb3be4acff4c3d14b95b2cbad6dad6e">更多...</a><br /></td></tr>
<tr class="separator:aecb3be4acff4c3d14b95b2cbad6dad6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7c4e681a315fe0b0f88fe21daa5e77"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a0f7c4e681a315fe0b0f88fe21daa5e77">task_done_cv</a> = {}</td></tr>
<tr class="memdesc:a0f7c4e681a315fe0b0f88fe21daa5e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition variable used to notify <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> that a tasks is done.  <a href="a00360.html#a0f7c4e681a315fe0b0f88fe21daa5e77">更多...</a><br /></td></tr>
<tr class="separator:a0f7c4e681a315fe0b0f88fe21daa5e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd4757e864a90eaf2144a50c7cd761f"><td class="memItemLeft" align="right" valign="top">std::queue&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a> = {}</td></tr>
<tr class="memdesc:adcd4757e864a90eaf2144a50c7cd761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue of tasks to be executed by the threads.  <a href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">更多...</a><br /></td></tr>
<tr class="separator:adcd4757e864a90eaf2144a50c7cd761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e427c4c79410f51d57e12fcbfab1e1"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">tasks_total</a> = 0</td></tr>
<tr class="memdesc:ae9e427c4c79410f51d57e12fcbfab1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable to keep track of the total number of unfinished tasks - either still in the queue, or running in a thread.  <a href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">更多...</a><br /></td></tr>
<tr class="separator:ae9e427c4c79410f51d57e12fcbfab1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf8504f1b1a651bc0a714a65a8817c5"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a> = {}</td></tr>
<tr class="memdesc:a5cf8504f1b1a651bc0a714a65a8817c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex to synchronize access to the task queue by different threads.  <a href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">更多...</a><br /></td></tr>
<tr class="separator:a5cf8504f1b1a651bc0a714a65a8817c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a83012732b16fce9fb87a6bc37a8d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a> = 0</td></tr>
<tr class="memdesc:a19a83012732b16fce9fb87a6bc37a8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of threads in the pool.  <a href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">更多...</a><br /></td></tr>
<tr class="separator:a19a83012732b16fce9fb87a6bc37a8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d390bd82d042e989baf9783bb424ae3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::thread[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a7d390bd82d042e989baf9783bb424ae3">threads</a> = nullptr</td></tr>
<tr class="memdesc:a7d390bd82d042e989baf9783bb424ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer to manage the memory allocated for the threads.  <a href="a00360.html#a7d390bd82d042e989baf9783bb424ae3">更多...</a><br /></td></tr>
<tr class="separator:a7d390bd82d042e989baf9783bb424ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437427b45f891b3b39c22b4a9884974e"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#a437427b45f891b3b39c22b4a9884974e">waiting</a> = false</td></tr>
<tr class="memdesc:a437427b45f891b3b39c22b4a9884974e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable indicating that <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> is active and expects to be notified whenever a task is done.  <a href="a00360.html#a437427b45f891b3b39c22b4a9884974e">更多...</a><br /></td></tr>
<tr class="separator:a437427b45f891b3b39c22b4a9884974e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc29c3a5dd87615603f1c7a595e905dc"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">threadIndexCounter</a> = 0</td></tr>
<tr class="separator:afc29c3a5dd87615603f1c7a595e905dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p >A fast, lightweight, and easy-to-use C++17 thread pool class. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00227">227</a> 行定义.</p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a id="af0705b5edcf3809e4f133272e8070d12" name="af0705b5edcf3809e4f133272e8070d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0705b5edcf3809e4f133272e8070d12">&#9670;&nbsp;</a></span>thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>thread_count_</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count_</td><td>The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00238">238</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>                                                           : <a class="code hl_variable" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>(<a class="code hl_function" href="a00360.html#ad40078e42bdcf2c562489984f94092e9">determine_thread_count</a>(thread_count_)), <a class="code hl_variable" href="a00360.html#a7d390bd82d042e989baf9783bb424ae3">threads</a>(std::make_unique&lt;std::thread[]&gt;(<a class="code hl_function" href="a00360.html#ad40078e42bdcf2c562489984f94092e9">determine_thread_count</a>(thread_count_))) {</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span>            <a class="code hl_function" href="a00360.html#a4b6564dcbe7b01efb736377917b489b8">create_threads</a>();</div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span>        }</div>
<div class="ttc" id="aa00360_html_a19a83012732b16fce9fb87a6bc37a8d4"><div class="ttname"><a href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">BS::thread_pool::thread_count</a></div><div class="ttdeci">concurrency_t thread_count</div><div class="ttdoc">The number of threads in the pool.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00684">BS_thread_pool.hpp:684</a></div></div>
<div class="ttc" id="aa00360_html_a4b6564dcbe7b01efb736377917b489b8"><div class="ttname"><a href="a00360.html#a4b6564dcbe7b01efb736377917b489b8">BS::thread_pool::create_threads</a></div><div class="ttdeci">void create_threads()</div><div class="ttdoc">Create the threads in the pool and assign a worker to each thread.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00572">BS_thread_pool.hpp:572</a></div></div>
<div class="ttc" id="aa00360_html_a7d390bd82d042e989baf9783bb424ae3"><div class="ttname"><a href="a00360.html#a7d390bd82d042e989baf9783bb424ae3">BS::thread_pool::threads</a></div><div class="ttdeci">std::unique_ptr&lt; std::thread[]&gt; threads</div><div class="ttdoc">A smart pointer to manage the memory allocated for the threads.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00689">BS_thread_pool.hpp:689</a></div></div>
<div class="ttc" id="aa00360_html_ad40078e42bdcf2c562489984f94092e9"><div class="ttname"><a href="a00360.html#ad40078e42bdcf2c562489984f94092e9">BS::thread_pool::determine_thread_count</a></div><div class="ttdeci">concurrency_t determine_thread_count(const concurrency_t thread_count_)</div><div class="ttdoc">Determine how many threads the pool should have, based on the parameter passed to the constructor or ...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00598">BS_thread_pool.hpp:598</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f7cc32367d0d0c020bf103782506998" name="a1f7cc32367d0d0c020bf103782506998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7cc32367d0d0c020bf103782506998">&#9670;&nbsp;</a></span>~thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::~thread_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the thread pool. Waits for all tasks to complete, then destroys all threads. Note that if the pool is paused, then any tasks still in the queue will never be executed. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00245">245</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span>                       {</div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span>            <a class="code hl_function" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8">wait_for_tasks</a>();</div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span>            <a class="code hl_function" href="a00360.html#a97b4777cae9085a4fa792a334f1015d6">destroy_threads</a>();</div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span>        }</div>
<div class="ttc" id="aa00360_html_a1e16153b1a14b5b4d8191168ccf6e4b8"><div class="ttname"><a href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8">BS::thread_pool::wait_for_tasks</a></div><div class="ttdeci">void wait_for_tasks()</div><div class="ttdoc">Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00542">BS_thread_pool.hpp:542</a></div></div>
<div class="ttc" id="aa00360_html_a97b4777cae9085a4fa792a334f1015d6"><div class="ttname"><a href="a00360.html#a97b4777cae9085a4fa792a334f1015d6">BS::thread_pool::destroy_threads</a></div><div class="ttdeci">void destroy_threads()</div><div class="ttdoc">Destroy the threads in the pool.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00584">BS_thread_pool.hpp:584</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a4b6564dcbe7b01efb736377917b489b8" name="a4b6564dcbe7b01efb736377917b489b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6564dcbe7b01efb736377917b489b8">&#9670;&nbsp;</a></span>create_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::create_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the threads in the pool and assign a worker to each thread. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00572">572</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span>                              {</div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span>            <a class="code hl_variable" href="a00360.html#a1230911736c885623eeb34c537dcd679">running</a> = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span>            <a class="code hl_variable" href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">threadIndexCounter</a> = 0;</div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span>            <span class="keywordflow">for</span> (<a class="code hl_typedef" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> i = 0; i &lt; <a class="code hl_variable" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>; ++i) {</div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span>                <span class="keywordflow">while</span> (<a class="code hl_variable" href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">threadIndexCounter</a> != i) [[unlikely]] std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span>                <a class="code hl_variable" href="a00360.html#a7d390bd82d042e989baf9783bb424ae3">threads</a>[i] = std::thread(&amp;<a class="code hl_function" href="a00360.html#a6f36df0501ab738b10baee833e9ed960">thread_pool::worker</a>, <span class="keyword">this</span>);</div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span>            }</div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span>        }</div>
<div class="ttc" id="aa00311_html_a7bb1747ef283bd1349183c445ee89aaa"><div class="ttname"><a href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">BS::concurrency_t</a></div><div class="ttdeci">std::invoke_result_t&lt; decltype(std::thread::hardware_concurrency)&gt; concurrency_t</div><div class="ttdoc">A convenient shorthand for the type of std::thread::hardware_concurrency(). Should evaluate to unsign...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00038">BS_thread_pool.hpp:38</a></div></div>
<div class="ttc" id="aa00360_html_a1230911736c885623eeb34c537dcd679"><div class="ttname"><a href="a00360.html#a1230911736c885623eeb34c537dcd679">BS::thread_pool::running</a></div><div class="ttdeci">std::atomic&lt; bool &gt; running</div><div class="ttdoc">An atomic variable indicating to the workers to keep running. When set to false, the workers permanen...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00654">BS_thread_pool.hpp:654</a></div></div>
<div class="ttc" id="aa00360_html_a6f36df0501ab738b10baee833e9ed960"><div class="ttname"><a href="a00360.html#a6f36df0501ab738b10baee833e9ed960">BS::thread_pool::worker</a></div><div class="ttdeci">void worker()</div><div class="ttdoc">A worker function to be assigned to each thread in the pool. Waits until it is notified by push_task(...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00622">BS_thread_pool.hpp:622</a></div></div>
<div class="ttc" id="aa00360_html_afc29c3a5dd87615603f1c7a595e905dc"><div class="ttname"><a href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">BS::thread_pool::threadIndexCounter</a></div><div class="ttdeci">std::atomic&lt; size_t &gt; threadIndexCounter</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00696">BS_thread_pool.hpp:696</a></div></div>
</div><!-- fragment --><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> 函数调用图:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00360_a4b6564dcbe7b01efb736377917b489b8_cgraph.svg" width="772" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a97b4777cae9085a4fa792a334f1015d6" name="a97b4777cae9085a4fa792a334f1015d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b4777cae9085a4fa792a334f1015d6">&#9670;&nbsp;</a></span>destroy_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::destroy_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the threads in the pool. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00584">584</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span>                               {</div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span>            <a class="code hl_variable" href="a00360.html#a1230911736c885623eeb34c537dcd679">running</a> = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span>            <a class="code hl_variable" href="a00360.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a>.notify_all();</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span>            <span class="keywordflow">for</span> (<a class="code hl_typedef" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> i = 0; i &lt; <a class="code hl_variable" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>; ++i) {</div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span>                <a class="code hl_variable" href="a00360.html#a7d390bd82d042e989baf9783bb424ae3">threads</a>[i].join();</div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span>            }</div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span>        }</div>
<div class="ttc" id="aa00360_html_aecb3be4acff4c3d14b95b2cbad6dad6e"><div class="ttname"><a href="a00360.html#aecb3be4acff4c3d14b95b2cbad6dad6e">BS::thread_pool::task_available_cv</a></div><div class="ttdeci">std::condition_variable task_available_cv</div><div class="ttdoc">A condition variable used to notify worker() that a new task has become available.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00659">BS_thread_pool.hpp:659</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad40078e42bdcf2c562489984f94092e9" name="ad40078e42bdcf2c562489984f94092e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40078e42bdcf2c562489984f94092e9">&#9670;&nbsp;</a></span>determine_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool::determine_thread_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>thread_count_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine how many threads the pool should have, based on the parameter passed to the constructor or <a class="el" href="a00360.html#a5d3623b19c51a513fe4612b2157b0314" title="Reset the number of threads in the pool. Waits for all currently running tasks to be completed,...">reset()</a>. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count_</td><td>The parameter passed to the constructor or <a class="el" href="a00360.html#a5d3623b19c51a513fe4612b2157b0314" title="Reset the number of threads in the pool. Waits for all currently running tasks to be completed,...">reset()</a>. If the parameter is a positive number, then the pool will be created with this number of threads. If the parameter is non-positive, or a parameter was not supplied (in which case it will have the default value of 0), then the pool will be created with the total number of hardware threads available, as obtained from std::thread::hardware_concurrency(). If the latter returns a non-positive number for some reason, then the pool will be created with just one thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The number of threads to use for constructing the pool. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00598">598</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span>                                                                                              {</div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span>            <span class="keywordflow">if</span> (thread_count_ &gt; 0)</div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span>                <span class="keywordflow">return</span> thread_count_;</div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span>            <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span>                <span class="keywordflow">if</span> (std::thread::hardware_concurrency() &gt; 0)</div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span>                    <span class="keywordflow">return</span> std::thread::hardware_concurrency();</div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span>                <span class="keywordflow">else</span></div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span>                    <span class="keywordflow">return</span> 1;</div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span>            }</div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5faf242cb0eacbb5c1142a2bd966468" name="ab5faf242cb0eacbb5c1142a2bd966468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5faf242cb0eacbb5c1142a2bd966468">&#9670;&nbsp;</a></span>get_tasks_queued()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BS::thread_pool::get_tasks_queued </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently waiting in the queue to be executed by the threads. </p>
<dl class="section return"><dt>返回</dt><dd>The number of queued tasks. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00259">259</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span>                                                      {</div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span>            <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code hl_variable" href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.size();</div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span>        }</div>
<div class="ttc" id="aa00360_html_a5cf8504f1b1a651bc0a714a65a8817c5"><div class="ttname"><a href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">BS::thread_pool::tasks_mutex</a></div><div class="ttdeci">std::mutex tasks_mutex</div><div class="ttdoc">A mutex to synchronize access to the task queue by different threads.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00679">BS_thread_pool.hpp:679</a></div></div>
<div class="ttc" id="aa00360_html_adcd4757e864a90eaf2144a50c7cd761f"><div class="ttname"><a href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">BS::thread_pool::tasks</a></div><div class="ttdeci">std::queue&lt; std::function&lt; void()&gt; &gt; tasks</div><div class="ttdoc">A queue of tasks to be executed by the threads.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00669">BS_thread_pool.hpp:669</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a07b4d97e3a9e40e3228e2ed1f9a717cc" name="a07b4d97e3a9e40e3228e2ed1f9a717cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b4d97e3a9e40e3228e2ed1f9a717cc">&#9670;&nbsp;</a></span>get_tasks_running()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BS::thread_pool::get_tasks_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently being executed by the threads. </p>
<dl class="section return"><dt>返回</dt><dd>The number of running tasks. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00269">269</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span>                                                       {</div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span>            <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code hl_variable" href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">tasks_total</a> - <a class="code hl_variable" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.size();</div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span>        }</div>
<div class="ttc" id="aa00360_html_ae9e427c4c79410f51d57e12fcbfab1e1"><div class="ttname"><a href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">BS::thread_pool::tasks_total</a></div><div class="ttdeci">std::atomic&lt; size_t &gt; tasks_total</div><div class="ttdoc">An atomic variable to keep track of the total number of unfinished tasks - either still in the queue,...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00674">BS_thread_pool.hpp:674</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afdec64ff8998d66017cc185ae397e064" name="afdec64ff8998d66017cc185ae397e064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdec64ff8998d66017cc185ae397e064">&#9670;&nbsp;</a></span>get_tasks_total()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t BS::thread_pool::get_tasks_total </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of unfinished tasks: either still in the queue, or running in a thread. Note that <a class="el" href="a00360.html#afdec64ff8998d66017cc185ae397e064" title="Get the total number of unfinished tasks: either still in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="a00360.html#ab5faf242cb0eacbb5c1142a2bd966468" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="a00360.html#a07b4d97e3a9e40e3228e2ed1f9a717cc" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a>. </p>
<dl class="section return"><dt>返回</dt><dd>The total number of tasks. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00279">279</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span>                                                     {</div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">tasks_total</a>;</div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afe1cb80839e30f218818e99af4d1dc64" name="afe1cb80839e30f218818e99af4d1dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1cb80839e30f218818e99af4d1dc64">&#9670;&nbsp;</a></span>get_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool::get_thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads in the pool. </p>
<dl class="section return"><dt>返回</dt><dd>The number of threads. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00288">288</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span>                                                             {</div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>;</div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac50afec1dec9015d36c90f49c9a4ff80" name="ac50afec1dec9015d36c90f49c9a4ff80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50afec1dec9015d36c90f49c9a4ff80">&#9670;&nbsp;</a></span>getCurrentThreadIndexView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t BS::thread_pool::getCurrentThreadIndexView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00549">549</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span>{ <span class="keywordflow">return</span> <a class="code hl_function" href="a00360.html#a03a26302bfc4d7a75df02e187af3a77b">getThreadIndex</a>(); }</div>
<div class="ttc" id="aa00360_html_a03a26302bfc4d7a75df02e187af3a77b"><div class="ttname"><a href="a00360.html#a03a26302bfc4d7a75df02e187af3a77b">BS::thread_pool::getThreadIndex</a></div><div class="ttdeci">static size_t &amp; getThreadIndex()</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00609">BS_thread_pool.hpp:609</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a03a26302bfc4d7a75df02e187af3a77b" name="a03a26302bfc4d7a75df02e187af3a77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a26302bfc4d7a75df02e187af3a77b">&#9670;&nbsp;</a></span>getThreadIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t &amp; BS::thread_pool::getThreadIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00609">609</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span>                                        {</div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span>            <span class="comment">// for windows compatibility, use parentheses to avoid calling the macro &quot;max&quot;</span></div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span>            <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keywordtype">size_t</span> index = (std::numeric_limits&lt;size_t&gt;::max)();</div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span>            <span class="keywordflow">return</span> index;</div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adc7938f7b2b9140c3f6e729b48db79b2" name="adc7938f7b2b9140c3f6e729b48db79b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7938f7b2b9140c3f6e729b48db79b2">&#9670;&nbsp;</a></span>is_paused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BS::thread_pool::is_paused </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the pool is currently paused. </p>
<dl class="section return"><dt>返回</dt><dd>true if the pool is paused, false if it is not paused. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00297">297</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span>                                             {</div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a>;</div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span>        }</div>
<div class="ttc" id="aa00360_html_a144417a3a9099c5658911632b4092f91"><div class="ttname"><a href="a00360.html#a144417a3a9099c5658911632b4092f91">BS::thread_pool::paused</a></div><div class="ttdeci">std::atomic&lt; bool &gt; paused</div><div class="ttdoc">An atomic variable indicating whether the workers should pause. When set to true, the workers tempora...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00649">BS_thread_pool.hpp:649</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f4e0c7b8e0ac08d9cdad40defd36f30" name="a2f4e0c7b8e0ac08d9cdad40defd36f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4e0c7b8e0ac08d9cdad40defd36f30">&#9670;&nbsp;</a></span>parallelize_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00352.html">multi_future</a>&lt; R &gt; BS::thread_pool::parallelize_loop </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks. This overload is used for the special case where the first index is 0. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T</td><td>The type of the loop indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">R</td><td>The return value of the loop function F (can be void). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from 0 to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = 0; i &lt; index_after_last; ++i)". Note that if index_after_last == 0, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that can be used to wait for all the blocks to finish. If the loop function returns a value, the <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object can also be used to obtain the values returned by each block. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00375">375</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00375" name="l00375"></a><span class="lineno">  375</span>                                                                                                                        {</div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="a00360.html#ab63b1085ad48295d7f653cbb36a286be">parallelize_loop</a>(0, index_after_last, std::forward&lt;F&gt;(loop), num_blocks);</div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span>        }</div>
<div class="ttc" id="aa00360_html_ab63b1085ad48295d7f653cbb36a286be"><div class="ttname"><a href="a00360.html#ab63b1085ad48295d7f653cbb36a286be">BS::thread_pool::parallelize_loop</a></div><div class="ttdeci">multi_future&lt; R &gt; parallelize_loop(const T1 first_index, const T2 index_after_last, F &amp;&amp;loop, const size_t num_blocks=0)</div><div class="ttdoc">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to ...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00348">BS_thread_pool.hpp:348</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab63b1085ad48295d7f653cbb36a286be" name="ab63b1085ad48295d7f653cbb36a286be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63b1085ad48295d7f653cbb36a286be">&#9670;&nbsp;</a></span>parallelize_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T1 , typename T2 , typename T  = std::common_type_t&lt;T1, T2&gt;, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00352.html">multi_future</a>&lt; R &gt; BS::thread_pool::parallelize_loop </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T1</td><td>The type of the first index in the loop. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index in the loop. Should be a signed or unsigned integer. If T1 is not the same as T2, a common type will be automatically inferred. </td></tr>
    <tr><td class="paramname">T</td><td>The common type of T1 and T2. </td></tr>
    <tr><td class="paramname">R</td><td>The return value of the loop function F (can be void). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from first_index to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = first_index; i &lt; index_after_last; ++i)". Note that if index_after_last == first_index, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that can be used to wait for all the blocks to finish. If the loop function returns a value, the <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object can also be used to obtain the values returned by each block. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00348">348</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span>                                                                                                                                               {</div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span>            blocks blks(first_index, index_after_last, num_blocks ? num_blocks : <a class="code hl_variable" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span>            <span class="keywordflow">if</span> (blks.get_total_size() &gt; 0) {</div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span>                multi_future&lt;R&gt; mf(blks.get_num_blocks());</div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span>                {</div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span>                    std::scoped_lock lk(<a class="code hl_variable" href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; blks.get_num_blocks(); ++i)</div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span>                        mf[i] = <a class="code hl_function" href="a00360.html#ae60f93ff4ee8fae28b5945eb9a6fc7fa">submit_nolock</a>(std::forward&lt;F&gt;(loop), blks.start(i), blks.end(i));</div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span>                }</div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span>                <span class="keywordflow">return</span> mf;</div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno">  358</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span>                <span class="keywordflow">return</span> multi_future&lt;R&gt;();</div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span>            }</div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span>        }</div>
<div class="ttc" id="aa00360_html_ae60f93ff4ee8fae28b5945eb9a6fc7fa"><div class="ttname"><a href="a00360.html#ae60f93ff4ee8fae28b5945eb9a6fc7fa">BS::thread_pool::submit_nolock</a></div><div class="ttdeci">std::future&lt; R &gt; submit_nolock(F &amp;&amp;task, A &amp;&amp;...args)</div><div class="ttdoc">Same as submit, but without locking mutex.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00508">BS_thread_pool.hpp:508</a></div></div>
</div><!-- fragment --><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> 函数调用图:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00360_ab63b1085ad48295d7f653cbb36a286be_cgraph.svg" width="446" height="206"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aefb5f1e179eb97f6458d4f77fbb331fd" name="aefb5f1e179eb97f6458d4f77fbb331fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb5f1e179eb97f6458d4f77fbb331fd">&#9670;&nbsp;</a></span>pause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pause the pool. The workers will temporarily stop retrieving new tasks out of the queue, although any tasks already executed will keep running until they are finished. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00382">382</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span>                     {</div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span>            <a class="code hl_variable" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a> = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ffca1428e1f111220b5f9aed9ff9eac" name="a2ffca1428e1f111220b5f9aed9ff9eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffca1428e1f111220b5f9aed9ff9eac">&#9670;&nbsp;</a></span>push_loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::push_loop </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Does not return a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a>, so the user must use <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. This overload is used for the special case where the first index is 0. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T</td><td>The type of the loop indices. Should be a signed or unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from 0 to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = 0; i &lt; index_after_last; ++i)". Note that if index_after_last == 0, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00417">417</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span>                                                                                        {</div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span>            <a class="code hl_function" href="a00360.html#ae7cec549d4a8729beac50f5eba3ec63f">push_loop</a>(0, index_after_last, std::forward&lt;F&gt;(loop), num_blocks);</div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span>        }</div>
<div class="ttc" id="aa00360_html_ae7cec549d4a8729beac50f5eba3ec63f"><div class="ttname"><a href="a00360.html#ae7cec549d4a8729beac50f5eba3ec63f">BS::thread_pool::push_loop</a></div><div class="ttdeci">void push_loop(const T1 first_index, const T2 index_after_last, F &amp;&amp;loop, const size_t num_blocks=0)</div><div class="ttdoc">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to ...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00399">BS_thread_pool.hpp:399</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7cec549d4a8729beac50f5eba3ec63f" name="ae7cec549d4a8729beac50f5eba3ec63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cec549d4a8729beac50f5eba3ec63f">&#9670;&nbsp;</a></span>push_loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T1 , typename T2 , typename T  = std::common_type_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::push_loop </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Does not return a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a>, so the user must use <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T1</td><td>The type of the first index in the loop. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index in the loop. Should be a signed or unsigned integer. If T1 is not the same as T2, a common type will be automatically inferred. </td></tr>
    <tr><td class="paramname">T</td><td>The common type of T1 and T2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from first_index to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = first_index; i &lt; index_after_last; ++i)". Note that if index_after_last == first_index, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00399">399</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span>                                                                                                               {</div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span>            blocks blks(first_index, index_after_last, num_blocks ? num_blocks : <a class="code hl_variable" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span>            <span class="keywordflow">if</span> (blks.get_total_size() &gt; 0) {</div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span>                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; blks.get_num_blocks(); ++i)</div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span>                    <a class="code hl_function" href="a00360.html#a2ebd481672891be26e73f19f70b38e01">push_task</a>(std::forward&lt;F&gt;(loop), blks.start(i), blks.end(i));</div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span>            }</div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span>        }</div>
<div class="ttc" id="aa00360_html_a2ebd481672891be26e73f19f70b38e01"><div class="ttname"><a href="a00360.html#a2ebd481672891be26e73f19f70b38e01">BS::thread_pool::push_task</a></div><div class="ttdeci">void push_task(F &amp;&amp;task, A &amp;&amp;...args)</div><div class="ttdoc">Push a function with zero or more arguments, but no return value, into the task queue....</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00430">BS_thread_pool.hpp:430</a></div></div>
</div><!-- fragment --><div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> 函数调用图:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00360_ae7cec549d4a8729beac50f5eba3ec63f_cgraph.svg" width="416" height="272"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2ebd481672891be26e73f19f70b38e01" name="a2ebd481672891be26e73f19f70b38e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebd481672891be26e73f19f70b38e01">&#9670;&nbsp;</a></span>push_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::push_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a function with zero or more arguments, but no return value, into the task queue. Does not return a future, so the user must use <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> or some other method to ensure that the task finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to push. </td></tr>
    <tr><td class="paramname">args</td><td>The zero or more arguments to pass to the function. Note that if the task is a class member function, the first argument must be a pointer to the object, i.e. &amp;object (or this), followed by the actual arguments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00430">430</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span>                                              {</div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span>            std::function&lt;void()&gt; task_function = std::bind(std::forward&lt;F&gt;(task), std::forward&lt;A&gt;(args)...);</div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span>            {</div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span>                <span class="keyword">const</span> std::scoped_lock tasks_lock(<a class="code hl_variable" href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span>                <a class="code hl_variable" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.push(std::move(task_function));</div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span>            }</div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span>            ++<a class="code hl_variable" href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">tasks_total</a>;</div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span>            <a class="code hl_variable" href="a00360.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a>.notify_one();</div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c00ae5f87608bbc12b05f1ddf231196" name="a2c00ae5f87608bbc12b05f1ddf231196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c00ae5f87608bbc12b05f1ddf231196">&#9670;&nbsp;</a></span>push_task_nolock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::push_task_nolock </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as push_task, but without locking the mutex. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00444">444</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span>                                                     {</div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span>            std::function&lt;void()&gt; task_function = std::bind(std::forward&lt;F&gt;(task), std::forward&lt;A&gt;(args)...);</div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span>            {</div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span>                <a class="code hl_variable" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.push(std::move(task_function));</div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span>            }</div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span>            ++<a class="code hl_variable" href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">tasks_total</a>;</div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span>            <a class="code hl_variable" href="a00360.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a>.notify_one();</div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d3623b19c51a513fe4612b2157b0314" name="a5d3623b19c51a513fe4612b2157b0314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3623b19c51a513fe4612b2157b0314">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>thread_count_</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the number of threads in the pool. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count_</td><td>The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00458">458</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span>                                                          {</div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> was_paused = <a class="code hl_variable" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a>;</div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span>            <a class="code hl_variable" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a> = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span>            <a class="code hl_function" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8">wait_for_tasks</a>();</div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span>            <a class="code hl_function" href="a00360.html#a97b4777cae9085a4fa792a334f1015d6">destroy_threads</a>();</div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span>            <a class="code hl_variable" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a> = <a class="code hl_function" href="a00360.html#ad40078e42bdcf2c562489984f94092e9">determine_thread_count</a>(thread_count_);</div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span>            <a class="code hl_variable" href="a00360.html#a7d390bd82d042e989baf9783bb424ae3">threads</a> = std::make_unique&lt;std::thread[]&gt;(<a class="code hl_variable" href="a00360.html#a19a83012732b16fce9fb87a6bc37a8d4">thread_count</a>);</div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span>            <a class="code hl_variable" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a> = was_paused;</div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span>            <a class="code hl_function" href="a00360.html#a4b6564dcbe7b01efb736377917b489b8">create_threads</a>();</div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac43e9ad7abf11f7f874c356a483eb76d" name="ac43e9ad7abf11f7f874c356a483eb76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43e9ad7abf11f7f874c356a483eb76d">&#9670;&nbsp;</a></span>resetThreadByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::resetThreadByIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>force reset a thread, only should be called when a deadly problem happen </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00552">552</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span>                                              {</div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span>            <span class="keyword">static</span> std::mutex resetThreadMtx;</div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span>            std::lock_guard lk(resetThreadMtx);</div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span>            <span class="keywordtype">size_t</span> oldThCounter = <a class="code hl_variable" href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">threadIndexCounter</a>;</div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span>            <a class="code hl_variable" href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">threadIndexCounter</a> = index;</div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span>            <a class="code hl_variable" href="a00307.html#a0e16fc1159d498289bcda90fcd7a734c">LibLoader::logger</a>.<a class="code hl_function" href="a00396.html#af50d0545fe7d683e54fcd03453a423e3">warning</a>(<span class="stringliteral">&quot;resetting thread in pool at index &quot;</span> + std::to_string(index)+<span class="stringliteral">&quot; due to a user caused error&quot;</span>);</div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span>            <span class="keyword">new</span> (&amp;<a class="code hl_variable" href="a00360.html#a7d390bd82d042e989baf9783bb424ae3">threads</a>[index]) std::thread(&amp;<a class="code hl_function" href="a00360.html#a6f36df0501ab738b10baee833e9ed960">thread_pool::worker</a>, <span class="keyword">this</span>);</div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span>            <span class="keywordflow">while</span> (<a class="code hl_variable" href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">threadIndexCounter</a> != index + 1)</div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span>                ;</div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span>            <a class="code hl_variable" href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">threadIndexCounter</a> = oldThCounter;</div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span>        }</div>
<div class="ttc" id="aa00307_html_a0e16fc1159d498289bcda90fcd7a734c"><div class="ttname"><a href="a00307.html#a0e16fc1159d498289bcda90fcd7a734c">LibLoader::logger</a></div><div class="ttdeci">MIRAICP_EXPORT LoaderLogger logger</div><div class="ttdef"><b>Definition:</b> <a href="a00215_source.html#l00035">LoaderLogger.cpp:35</a></div></div>
<div class="ttc" id="aa00396_html_af50d0545fe7d683e54fcd03453a423e3"><div class="ttname"><a href="a00396.html#af50d0545fe7d683e54fcd03453a423e3">LibLoader::LoaderLogger::warning</a></div><div class="ttdeci">void warning(const string &amp;) const</div><div class="ttdef"><b>Definition:</b> <a href="a00215_source.html#l00047">LoaderLogger.cpp:47</a></div></div>
</div><!-- fragment --><div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> 函数调用图:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00360_ac43e9ad7abf11f7f874c356a483eb76d_cgraph.svg" width="1539" height="210"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a229fc62ea9874f840613fdefe1f6018b" name="a229fc62ea9874f840613fdefe1f6018b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229fc62ea9874f840613fdefe1f6018b">&#9670;&nbsp;</a></span>run_over()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00352.html">multi_future</a>&lt; R &gt; BS::thread_pool::run_over </td>
          <td>(</td>
          <td class="paramtype">It &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue. Returns a <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">T1</td><td>The type of the first index in the loop. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index in the loop. Should be a signed or unsigned integer. If T1 is not the same as T2, a common type will be automatically inferred. </td></tr>
    <tr><td class="paramname">T</td><td>The common type of T1 and T2. </td></tr>
    <tr><td class="paramname">R</td><td>The return value of the loop function F (can be void). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from first_index to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = first_index; i &lt; index_after_last; ++i)". Note that if index_after_last == first_index, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; ++i)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object that can be used to wait for all the blocks to finish. If the loop function returns a value, the <a class="el" href="a00352.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a> object can also be used to obtain the values returned by each block. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00316">316</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span>                                                                                    {</div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span>            It ptr = begin;</div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span>            <span class="keywordflow">if</span> (inSize) {</div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span>                multi_future&lt;R&gt; mf(inSize);</div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span>                {</div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span>                    std::scoped_lock lk(<a class="code hl_variable" href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span>                    <span class="keywordtype">size_t</span> i = 0;</div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span>                    <span class="keywordflow">while</span> (ptr != end &amp;&amp; i &lt; inSize) {</div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span>                        mf[i++] = <a class="code hl_function" href="a00360.html#ae60f93ff4ee8fae28b5945eb9a6fc7fa">submit_nolock</a>(*ptr);</div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span>                    }</div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span>                }</div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span>                <span class="keywordflow">return</span> mf;</div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span>                <span class="keywordflow">return</span> multi_future&lt;R&gt;();</div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span>            }</div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a77bfe8e50c6bb28c590e965b27a6c1d7" name="a77bfe8e50c6bb28c590e965b27a6c1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bfe8e50c6bb28c590e965b27a6c1d7">&#9670;&nbsp;</a></span>setThreadIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::setThreadIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00615">615</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span>                              {</div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span>            <a class="code hl_function" href="a00360.html#a03a26302bfc4d7a75df02e187af3a77b">getThreadIndex</a>() = <a class="code hl_variable" href="a00360.html#afc29c3a5dd87615603f1c7a595e905dc">threadIndexCounter</a>++;</div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeff5c3b86d8c89227a2af192e3f96ef8" name="aeff5c3b86d8c89227a2af192e3f96ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff5c3b86d8c89227a2af192e3f96ef8">&#9670;&nbsp;</a></span>submit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; R &gt; BS::thread_pool::submit </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with zero or more arguments into the task queue. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an std::future&lt;void&gt; which can be used to wait until the task finishes. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the zero or more arguments to pass to the function. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function (can be void). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">args</td><td>The zero or more arguments to pass to the function. Note that if the task is a class member function, the first argument must be a pointer to the object, i.e. &amp;object (or this), followed by the actual arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A future to be used later to wait for the function to finish executing and/or obtain its returned value if it has one. </dd></dl>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00480">480</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span>                                                                 {</div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span>            <span class="keyword">auto</span> task_promise = <span class="keyword">new</span> std::promise&lt;R&gt;;</div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span>            <span class="keyword">auto</span> future = task_promise-&gt;get_future();</div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span>            <a class="code hl_function" href="a00360.html#a2ebd481672891be26e73f19f70b38e01">push_task</a>(</div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span>                    [task_promise](<span class="keyword">auto</span> &amp;&amp;task_inner, <span class="keyword">auto</span> &amp;&amp;...argss) {</div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span>                        <span class="keywordflow">try</span> {</div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span>                            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_void_v&lt;R&gt;) {</div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span>                                std::invoke(std::forward&lt;<span class="keyword">decltype</span>(task_inner)&gt;(task_inner), std::forward&lt;<span class="keyword">decltype</span>(argss)&gt;(argss)...);</div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span>                                task_promise-&gt;set_value();</div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span>                                task_promise-&gt;set_value(std::invoke(std::forward&lt;<span class="keyword">decltype</span>(task_inner)&gt;(task_inner), std::forward&lt;<span class="keyword">decltype</span>(argss)&gt;(argss)...));</div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span>                            }</div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span>                        } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span>                            <span class="keywordflow">try</span> {</div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span>                                task_promise-&gt;set_exception(std::current_exception());</div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span>                            } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span>                            }</div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span>                        }</div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span>                        <span class="keyword">delete</span> task_promise;</div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span>                    },</div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span>                    std::forward&lt;F&gt;(task), std::forward&lt;A&gt;(args)...);</div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span>            <span class="keywordflow">return</span> future;</div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span>        }</div>
</div><!-- fragment --><div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> 函数调用图:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00360_aeff5c3b86d8c89227a2af192e3f96ef8_cgraph.svg" width="364" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae60f93ff4ee8fae28b5945eb9a6fc7fa" name="ae60f93ff4ee8fae28b5945eb9a6fc7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60f93ff4ee8fae28b5945eb9a6fc7fa">&#9670;&nbsp;</a></span>submit_nolock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; R &gt; BS::thread_pool::submit_nolock </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as submit, but without locking mutex. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00508">508</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span>                                                                        {</div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span>            <span class="keyword">auto</span> task_promise = <span class="keyword">new</span> std::promise&lt;R&gt;;</div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span>            <span class="keyword">auto</span> future = task_promise-&gt;get_future();</div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span>            <a class="code hl_function" href="a00360.html#a2c00ae5f87608bbc12b05f1ddf231196">push_task_nolock</a>(</div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span>                    [task_promise](<span class="keyword">auto</span> &amp;&amp;task_inner, <span class="keyword">auto</span> &amp;&amp;...argss) {</div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span>                        <span class="keywordflow">try</span> {</div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span>                            <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_void_v&lt;R&gt;) {</div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span>                                std::invoke(std::forward&lt;<span class="keyword">decltype</span>(task_inner)&gt;(task_inner), std::forward&lt;<span class="keyword">decltype</span>(argss)&gt;(argss)...);</div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span>                                task_promise-&gt;set_value();</div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span>                                task_promise-&gt;set_value(std::invoke(std::forward&lt;<span class="keyword">decltype</span>(task_inner)&gt;(task_inner), std::forward&lt;<span class="keyword">decltype</span>(argss)&gt;(argss)...));</div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span>                            }</div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span>                        } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span>                            <span class="keywordflow">try</span> {</div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span>                                task_promise-&gt;set_exception(std::current_exception());</div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span>                            } <span class="keywordflow">catch</span> (...) {</div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span>                            }</div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span>                        }</div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span>                        <span class="keyword">delete</span> task_promise;</div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span>                    },</div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span>                    std::forward&lt;F&gt;(task), std::forward&lt;A&gt;(args)...);</div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span>            <span class="keywordflow">return</span> future;</div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span>        }</div>
<div class="ttc" id="aa00360_html_a2c00ae5f87608bbc12b05f1ddf231196"><div class="ttname"><a href="a00360.html#a2c00ae5f87608bbc12b05f1ddf231196">BS::thread_pool::push_task_nolock</a></div><div class="ttdeci">void push_task_nolock(F &amp;&amp;task, A &amp;&amp;...args)</div><div class="ttdoc">Same as push_task, but without locking the mutex.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00444">BS_thread_pool.hpp:444</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad57048e0479f878af3ac3a27031a2d6e" name="ad57048e0479f878af3ac3a27031a2d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57048e0479f878af3ac3a27031a2d6e">&#9670;&nbsp;</a></span>unpause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::unpause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpause the pool. The workers will resume retrieving new tasks out of the queue. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00535">535</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span>                       {</div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span>            <a class="code hl_variable" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a> = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span>        }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e16153b1a14b5b4d8191168ccf6e4b8" name="a1e16153b1a14b5b4d8191168ccf6e4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e16153b1a14b5b4d8191168ccf6e4b8">&#9670;&nbsp;</a></span>wait_for_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::wait_for_tasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <a class="el" href="a00360.html#aeff5c3b86d8c89227a2af192e3f96ef8" title="Submit a function with zero or more arguments into the task queue. If the function has a return value...">submit()</a> instead, and call the wait() member function of the generated future. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00542">542</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span>                              {</div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span>            <a class="code hl_variable" href="a00360.html#a437427b45f891b3b39c22b4a9884974e">waiting</a> = <span class="keyword">true</span>;</div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span>            std::unique_lock&lt;std::mutex&gt; tasks_lock(<a class="code hl_variable" href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span>            <a class="code hl_variable" href="a00360.html#a0f7c4e681a315fe0b0f88fe21daa5e77">task_done_cv</a>.wait(tasks_lock, [<span class="keyword">this</span>] { <span class="keywordflow">return</span> (<a class="code hl_variable" href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">tasks_total</a> == (<a class="code hl_variable" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a> ? <a class="code hl_variable" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.size() : 0)); });</div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span>            <a class="code hl_variable" href="a00360.html#a437427b45f891b3b39c22b4a9884974e">waiting</a> = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span>        }</div>
<div class="ttc" id="aa00360_html_a0f7c4e681a315fe0b0f88fe21daa5e77"><div class="ttname"><a href="a00360.html#a0f7c4e681a315fe0b0f88fe21daa5e77">BS::thread_pool::task_done_cv</a></div><div class="ttdeci">std::condition_variable task_done_cv</div><div class="ttdoc">A condition variable used to notify wait_for_tasks() that a tasks is done.</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00664">BS_thread_pool.hpp:664</a></div></div>
<div class="ttc" id="aa00360_html_a437427b45f891b3b39c22b4a9884974e"><div class="ttname"><a href="a00360.html#a437427b45f891b3b39c22b4a9884974e">BS::thread_pool::waiting</a></div><div class="ttdeci">std::atomic&lt; bool &gt; waiting</div><div class="ttdoc">An atomic variable indicating that wait_for_tasks() is active and expects to be notified whenever a t...</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00694">BS_thread_pool.hpp:694</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f36df0501ab738b10baee833e9ed960" name="a6f36df0501ab738b10baee833e9ed960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f36df0501ab738b10baee833e9ed960">&#9670;&nbsp;</a></span>worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::worker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A worker function to be assigned to each thread in the pool. Waits until it is notified by <a class="el" href="a00360.html#a2ebd481672891be26e73f19f70b38e01" title="Push a function with zero or more arguments, but no return value, into the task queue....">push_task()</a> that a task is available, and then retrieves the task from the queue and executes it. Once the task finishes, the worker notifies <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> in case it is waiting. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00622">622</a> 行定义.</p>
<div class="fragment"><div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span>                      {</div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span>            <a class="code hl_function" href="a00017.html#a9f67720001db7976ed33085c42d81fb0">platform_set_thread_name</a>(<a class="code hl_function" href="a00017.html#a355ba908e1bbef8ea09eeed979a16520">platform_thread_self</a>(), <span class="stringliteral">&quot;LoaderWorker&quot;</span>);</div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span>            <a class="code hl_function" href="a00360.html#a77bfe8e50c6bb28c590e965b27a6c1d7">setThreadIndex</a>();</div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span>            <span class="keywordflow">while</span> (<a class="code hl_variable" href="a00360.html#a1230911736c885623eeb34c537dcd679">running</a>) {</div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span>                std::function&lt;void()&gt; task;</div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span>                std::unique_lock&lt;std::mutex&gt; tasks_lock(<a class="code hl_variable" href="a00360.html#a5cf8504f1b1a651bc0a714a65a8817c5">tasks_mutex</a>);</div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span>                <a class="code hl_variable" href="a00360.html#aecb3be4acff4c3d14b95b2cbad6dad6e">task_available_cv</a>.wait(tasks_lock, [<span class="keyword">this</span>] { <span class="keywordflow">return</span> !<a class="code hl_variable" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.empty() || !<a class="code hl_variable" href="a00360.html#a1230911736c885623eeb34c537dcd679">running</a>; });</div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span>                <span class="keywordflow">if</span> (<a class="code hl_variable" href="a00360.html#a1230911736c885623eeb34c537dcd679">running</a> &amp;&amp; !<a class="code hl_variable" href="a00360.html#a144417a3a9099c5658911632b4092f91">paused</a>) {</div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span>                    task = std::move(<a class="code hl_variable" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.front());</div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span>                    <a class="code hl_variable" href="a00360.html#adcd4757e864a90eaf2144a50c7cd761f">tasks</a>.pop();</div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span>                    tasks_lock.unlock();</div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span>                    task();</div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span>                    tasks_lock.lock();</div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span>                    --<a class="code hl_variable" href="a00360.html#ae9e427c4c79410f51d57e12fcbfab1e1">tasks_total</a>;</div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span>                    <span class="keywordflow">if</span> (<a class="code hl_variable" href="a00360.html#a437427b45f891b3b39c22b4a9884974e">waiting</a>)</div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span>                        <a class="code hl_variable" href="a00360.html#a0f7c4e681a315fe0b0f88fe21daa5e77">task_done_cv</a>.notify_one();</div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span>                }</div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span>            }</div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span>        }</div>
<div class="ttc" id="aa00017_html_a355ba908e1bbef8ea09eeed979a16520"><div class="ttname"><a href="a00017.html#a355ba908e1bbef8ea09eeed979a16520">platform_thread_self</a></div><div class="ttdeci">auto platform_thread_self()</div><div class="ttdef"><b>Definition:</b> <a href="a00017_source.html#l00061">PlatformThreading.h:61</a></div></div>
<div class="ttc" id="aa00017_html_a9f67720001db7976ed33085c42d81fb0"><div class="ttname"><a href="a00017.html#a9f67720001db7976ed33085c42d81fb0">platform_set_thread_name</a></div><div class="ttdeci">void platform_set_thread_name(decltype(platform_thread_self()) id, const char *name)</div><div class="ttdef"><b>Definition:</b> <a href="a00017_source.html#l00074">PlatformThreading.h:74</a></div></div>
<div class="ttc" id="aa00360_html_a77bfe8e50c6bb28c590e965b27a6c1d7"><div class="ttname"><a href="a00360.html#a77bfe8e50c6bb28c590e965b27a6c1d7">BS::thread_pool::setThreadIndex</a></div><div class="ttdeci">void setThreadIndex()</div><div class="ttdef"><b>Definition:</b> <a href="a00026_source.html#l00615">BS_thread_pool.hpp:615</a></div></div>
</div><!-- fragment --><div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> 函数调用图:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00360_a6f36df0501ab738b10baee833e9ed960_cgraph.svg" width="566" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="closed.png" alt="+"/> 这是这个函数的调用关系图:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00360_a6f36df0501ab738b10baee833e9ed960_icgraph.svg" width="411" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="a144417a3a9099c5658911632b4092f91" name="a144417a3a9099c5658911632b4092f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144417a3a9099c5658911632b4092f91">&#9670;&nbsp;</a></span>paused</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; BS::thread_pool::paused = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An atomic variable indicating whether the workers should pause. When set to true, the workers temporarily stop retrieving new tasks out of the queue, although any tasks already executed will keep running until they are finished. When set to false again, the workers resume retrieving tasks. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00649">649</a> 行定义.</p>

</div>
</div>
<a id="a1230911736c885623eeb34c537dcd679" name="a1230911736c885623eeb34c537dcd679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1230911736c885623eeb34c537dcd679">&#9670;&nbsp;</a></span>running</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; BS::thread_pool::running = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An atomic variable indicating to the workers to keep running. When set to false, the workers permanently stop working. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00654">654</a> 行定义.</p>

</div>
</div>
<a id="aecb3be4acff4c3d14b95b2cbad6dad6e" name="aecb3be4acff4c3d14b95b2cbad6dad6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb3be4acff4c3d14b95b2cbad6dad6e">&#9670;&nbsp;</a></span>task_available_cv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable BS::thread_pool::task_available_cv = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A condition variable used to notify <a class="el" href="a00360.html#a6f36df0501ab738b10baee833e9ed960" title="A worker function to be assigned to each thread in the pool. Waits until it is notified by push_task(...">worker()</a> that a new task has become available. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00659">659</a> 行定义.</p>

</div>
</div>
<a id="a0f7c4e681a315fe0b0f88fe21daa5e77" name="a0f7c4e681a315fe0b0f88fe21daa5e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7c4e681a315fe0b0f88fe21daa5e77">&#9670;&nbsp;</a></span>task_done_cv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable BS::thread_pool::task_done_cv = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A condition variable used to notify <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> that a tasks is done. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00664">664</a> 行定义.</p>

</div>
</div>
<a id="adcd4757e864a90eaf2144a50c7cd761f" name="adcd4757e864a90eaf2144a50c7cd761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd4757e864a90eaf2144a50c7cd761f">&#9670;&nbsp;</a></span>tasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;std::function&lt;void()&gt; &gt; BS::thread_pool::tasks = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A queue of tasks to be executed by the threads. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00669">669</a> 行定义.</p>

</div>
</div>
<a id="a5cf8504f1b1a651bc0a714a65a8817c5" name="a5cf8504f1b1a651bc0a714a65a8817c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf8504f1b1a651bc0a714a65a8817c5">&#9670;&nbsp;</a></span>tasks_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex BS::thread_pool::tasks_mutex = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mutex to synchronize access to the task queue by different threads. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00679">679</a> 行定义.</p>

</div>
</div>
<a id="ae9e427c4c79410f51d57e12fcbfab1e1" name="ae9e427c4c79410f51d57e12fcbfab1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e427c4c79410f51d57e12fcbfab1e1">&#9670;&nbsp;</a></span>tasks_total</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;size_t&gt; BS::thread_pool::tasks_total = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An atomic variable to keep track of the total number of unfinished tasks - either still in the queue, or running in a thread. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00674">674</a> 行定义.</p>

</div>
</div>
<a id="a19a83012732b16fce9fb87a6bc37a8d4" name="a19a83012732b16fce9fb87a6bc37a8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a83012732b16fce9fb87a6bc37a8d4">&#9670;&nbsp;</a></span>thread_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00311.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool::thread_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of threads in the pool. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00684">684</a> 行定义.</p>

</div>
</div>
<a id="afc29c3a5dd87615603f1c7a595e905dc" name="afc29c3a5dd87615603f1c7a595e905dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc29c3a5dd87615603f1c7a595e905dc">&#9670;&nbsp;</a></span>threadIndexCounter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;size_t&gt; BS::thread_pool::threadIndexCounter = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00696">696</a> 行定义.</p>

</div>
</div>
<a id="a7d390bd82d042e989baf9783bb424ae3" name="a7d390bd82d042e989baf9783bb424ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d390bd82d042e989baf9783bb424ae3">&#9670;&nbsp;</a></span>threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::thread[]&gt; BS::thread_pool::threads = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A smart pointer to manage the memory allocated for the threads. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00689">689</a> 行定义.</p>

</div>
</div>
<a id="a437427b45f891b3b39c22b4a9884974e" name="a437427b45f891b3b39c22b4a9884974e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437427b45f891b3b39c22b4a9884974e">&#9670;&nbsp;</a></span>waiting</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; BS::thread_pool::waiting = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An atomic variable indicating that <a class="el" href="a00360.html#a1e16153b1a14b5b4d8191168ccf6e4b8" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait_for_tasks()</a> is active and expects to be notified whenever a task is done. </p>

<p class="definition">在文件 <a class="el" href="a00026_source.html">BS_thread_pool.hpp</a> 第 <a class="el" href="a00026_source.html#l00694">694</a> 行定义.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li><a class="el" href="a00026_source.html">BS_thread_pool.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00311.html">BS</a></li><li class="navelem"><a class="el" href="a00360.html">thread_pool</a></li>
    <li class="footer">生成于 2023年 一月 21日 星期六 14:15:22 , 为 MiraiCP使用  <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
    </body>
</html>
